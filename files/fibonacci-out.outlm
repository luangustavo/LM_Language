   1  fibonacci(int limit) void {
          [0001, 0001] (0002,                   ID) {fibonacci}
          [0001, 0010] (0011,                   OP) {(}
          [0001, 0011] (0004,                  INT) {int}
          [0001, 0015] (0002,                   ID) {limit}
          [0001, 0020] (0012,                   CP) {)}
          [0001, 0022] (0003,                 VOID) {void}
          [0001, 0027] (0009,                   OK) {{}
   2      int count; 
          [0002, 0005] (0004,                  INT) {int}
          [0002, 0009] (0002,                   ID) {count}
          [0002, 0014] (0015,                  SCO) {;}
   3      int fib1; 
          [0003, 0005] (0004,                  INT) {int}
          [0003, 0009] (0002,                   ID) {fib1}
          [0003, 0013] (0015,                  SCO) {;}
   4      int fib2; 
          [0004, 0005] (0004,                  INT) {int}
          [0004, 0009] (0002,                   ID) {fib2}
          [0004, 0013] (0015,                  SCO) {;}
   5      int result;
          [0005, 0005] (0004,                  INT) {int}
          [0005, 0009] (0002,                   ID) {result}
          [0005, 0015] (0015,                  SCO) {;}
   6      fib1 = 1;
          [0006, 0005] (0002,                   ID) {fib1}
          [0006, 0010] (0039,                  ATR) {=}
          [0006, 0012] (0017,               CTEINT) {1}
          [0006, 0013] (0015,                  SCO) {;}
   7      fib2 = 1;
          [0007, 0005] (0002,                   ID) {fib2}
          [0007, 0010] (0039,                  ATR) {=}
          [0007, 0012] (0017,               CTEINT) {1}
          [0007, 0013] (0015,                  SCO) {;}
   8      if(limit == 0) { 
          [0008, 0005] (0022,                   IF) {if}
          [0008, 0007] (0011,                   OP) {(}
          [0008, 0008] (0002,                   ID) {limit}
          [0008, 0014] (0038,                  ORE) {==}
          [0008, 0017] (0017,               CTEINT) {0}
          [0008, 0018] (0012,                   CP) {)}
          [0008, 0020] (0009,                   OK) {{}
   9          print("0");
          [0009, 0009] (0027,                PRINT) {print}
          [0009, 0014] (0011,                   OP) {(}
          [0009, 0015] (0021,            CTESTRING) {"0"}
          [0009, 0018] (0012,                   CP) {)}
          [0009, 0019] (0015,                  SCO) {;}
  10      }else{
          [0010, 0005] (0010,                   CK) {}}
          [0010, 0006] (0023,                 ELSE) {else}
          [0010, 0010] (0009,                   OK) {{}
  11          when(result <= limit) {
          [0011, 0009] (0026,                 WHEN) {when}
          [0011, 0013] (0011,                   OP) {(}
          [0011, 0014] (0002,                   ID) {result}
          [0011, 0021] (0037,                  ORC) {<=}
          [0011, 0024] (0002,                   ID) {limit}
          [0011, 0029] (0012,                   CP) {)}
          [0011, 0031] (0009,                   OK) {{}
  12               if(count == 0){
          [0012, 0014] (0022,                   IF) {if}
          [0012, 0016] (0011,                   OP) {(}
          [0012, 0017] (0002,                   ID) {count}
          [0012, 0023] (0038,                  ORE) {==}
          [0012, 0026] (0017,               CTEINT) {0}
          [0012, 0027] (0012,                   CP) {)}
          [0012, 0028] (0009,                   OK) {{}
  13                    print("0");
          [0013, 0019] (0027,                PRINT) {print}
          [0013, 0024] (0011,                   OP) {(}
          [0013, 0025] (0021,            CTESTRING) {"0"}
          [0013, 0028] (0012,                   CP) {)}
          [0013, 0029] (0015,                  SCO) {;}
  14               }elif(count < 2) { 
          [0014, 0014] (0010,                   CK) {}}
          [0014, 0015] (0024,                 ELIF) {elif}
          [0014, 0019] (0011,                   OP) {(}
          [0014, 0020] (0002,                   ID) {count}
          [0014, 0026] (0037,                  ORC) {<}
          [0014, 0028] (0017,               CTEINT) {2}
          [0014, 0029] (0012,                   CP) {)}
          [0014, 0031] (0009,                   OK) {{}
  15                    print(",1");
          [0015, 0019] (0027,                PRINT) {print}
          [0015, 0024] (0011,                   OP) {(}
          [0015, 0025] (0021,            CTESTRING) {",1"}
          [0015, 0029] (0012,                   CP) {)}
          [0015, 0030] (0015,                  SCO) {;}
  16                    result = 1;
          [0016, 0019] (0002,                   ID) {result}
          [0016, 0026] (0039,                  ATR) {=}
          [0016, 0028] (0017,               CTEINT) {1}
          [0016, 0029] (0015,                  SCO) {;}
  17               }else { 
          [0017, 0014] (0010,                   CK) {}}
          [0017, 0015] (0023,                 ELSE) {else}
          [0017, 0020] (0009,                   OK) {{}
  18                    result = fib1 + fib2;
          [0018, 0019] (0002,                   ID) {result}
          [0018, 0026] (0039,                  ATR) {=}
          [0018, 0028] (0002,                   ID) {fib1}
          [0018, 0033] (0033,                  OPA) {+}
          [0018, 0035] (0002,                   ID) {fib2}
          [0018, 0039] (0015,                  SCO) {;}
  19                    fib1 = fib2;
          [0019, 0019] (0002,                   ID) {fib1}
          [0019, 0024] (0039,                  ATR) {=}
          [0019, 0026] (0002,                   ID) {fib2}
          [0019, 0030] (0015,                  SCO) {;}
  20                    fib2 = result;
          [0020, 0019] (0002,                   ID) {fib2}
          [0020, 0024] (0039,                  ATR) {=}
          [0020, 0026] (0002,                   ID) {result}
          [0020, 0032] (0015,                  SCO) {;}
  21                    if(result<=limit){
          [0021, 0019] (0022,                   IF) {if}
          [0021, 0021] (0011,                   OP) {(}
          [0021, 0022] (0002,                   ID) {result}
          [0021, 0028] (0037,                  ORC) {<=}
          [0021, 0030] (0002,                   ID) {limit}
          [0021, 0035] (0012,                   CP) {)}
          [0021, 0036] (0009,                   OK) {{}
  22                        print(",%d", result);
          [0022, 0023] (0027,                PRINT) {print}
          [0022, 0028] (0011,                   OP) {(}
          [0022, 0029] (0021,            CTESTRING) {",%d"}
          [0022, 0034] (0016,                 SPTR) {,}
          [0022, 0036] (0002,                   ID) {result}
          [0022, 0042] (0012,                   CP) {)}
          [0022, 0043] (0015,                  SCO) {;}
  23                    }; 
          [0023, 0019] (0010,                   CK) {}}
          [0023, 0020] (0015,                  SCO) {;}
  24               };
          [0024, 0014] (0010,                   CK) {}}
          [0024, 0015] (0015,                  SCO) {;}
  25               count = count + 1;
          [0025, 0014] (0002,                   ID) {count}
          [0025, 0020] (0039,                  ATR) {=}
          [0025, 0022] (0002,                   ID) {count}
          [0025, 0028] (0033,                  OPA) {+}
          [0025, 0030] (0017,               CTEINT) {1}
          [0025, 0031] (0015,                  SCO) {;}
  26           };
          [0026, 0010] (0010,                   CK) {}}
          [0026, 0011] (0015,                  SCO) {;}
  27      }; 
          [0027, 0005] (0010,                   CK) {}}
          [0027, 0006] (0015,                  SCO) {;}
  28  };
          [0028, 0001] (0010,                   CK) {}}
          [0028, 0002] (0015,                  SCO) {;}
  29  main() void {
          [0029, 0001] (0001,                 MAIN) {main}
          [0029, 0005] (0011,                   OP) {(}
          [0029, 0006] (0012,                   CP) {)}
          [0029, 0008] (0003,                 VOID) {void}
          [0029, 0013] (0009,                   OK) {{}
  30      int limit; 
          [0030, 0005] (0004,                  INT) {int}
          [0030, 0009] (0002,                   ID) {limit}
          [0030, 0014] (0015,                  SCO) {;}
  31      read(limit);
          [0031, 0005] (0028,                 READ) {read}
          [0031, 0009] (0011,                   OP) {(}
          [0031, 0010] (0002,                   ID) {limit}
          [0031, 0015] (0012,                   CP) {)}
          [0031, 0016] (0015,                  SCO) {;}
  32      fibonacci(limit);
          [0032, 0005] (0002,                   ID) {fibonacci}
          [0032, 0014] (0011,                   OP) {(}
          [0032, 0015] (0002,                   ID) {limit}
          [0032, 0020] (0012,                   CP) {)}
          [0032, 0021] (0015,                  SCO) {;}
  33  };
          [0033, 0001] (0010,                   CK) {}}
          [0033, 0002] (0015,                  SCO) {;}
